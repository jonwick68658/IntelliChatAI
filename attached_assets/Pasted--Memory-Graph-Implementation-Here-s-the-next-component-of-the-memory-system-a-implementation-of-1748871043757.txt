# Memory Graph Implementation

Here's the next component of the memory system: a implementation of the MemoryGraph class that will model the relationships between memory nodes.

```python
import networkx as nx
from typing import Dict, List, Set, Tuple, Optional
import logging
from memory import MemoryNode, MemorySystem

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MemoryGraph:
    """
    A graph-based representation of the memory system that models relationships between memory nodes.
    """
    
    def __init__(self, memory_system: MemorySystem):
        """
        Initialize the memory graph with a connection to the memory system.
        
        Args:
            memory_system: The memory system instance containing all memory nodes
        """
        self.memory_system = memory_system
        self.graph = nx.Graph()
        self._create_graph_schema()
        self._populate_graph()
        
    def _create_graph_schema(self):
        """
        Create the underlying graph structure for the memory system.
        """
        logger.info("Creating memory graph schema...")
        
        # Create initial nodes from all memory nodes
        nodes = self.memory_system.get_all_memory_nodes()
        for node in nodes:
            self.add_node(node.id, node.content[:200], category=node.category)
            
        logger.info(f"Created graph with {len(self.graph.nodes)} nodes")
        
    def _populate_graph(self):
        """
        Populate the graph with relationships based on semantic similarity.
        """
        logger.info("Populating memory graph with connections...")
        
        # Get all memory nodes
        nodes = self.memory_system.get_all_memory_nodes()
        
        if not nodes:
            logger.warning("No memory nodes available to create connections")
            return
            
        # Connect similar memories through vector similarity
        for i, node1 in enumerate(nodes):
            if i % 10 == 0:  # Log progress periodically
                logger.info(f"Processing node {i+1}/{len(nodes)}")
                
            for node2 in nodes[i+1:]:
                # Don't connect a node to itself
                if node1.id == node2.id:
                    continue
                    
                # Calculate similarity score
                similarity = self._calculate_similarity(node1, node2)
                
                # Only add connections with reasonable similarity
                if similarity > 0.3:  # Minimum similarity threshold
                    # Add weighted edge based on similarity (0.3-1.0)
                    weight = min(1.0, max(0.3, similarity))
                    self.add_edge(node1.id, node2.id, weight=weight, 
                                  relationship_type="SIMILAR", similarity=similarity)
                    logger.debug(f"Added connection between {node1.id[:8]} and {node2.id[:8]} with weight {weight:.3f}")
        
        logger.info("Memory graph populated with 1-way connections")
        
    def get_all_memory_nodes(self) -> List[MemoryNode]:
        """
        Get all memory nodes in the system.
        
        Returns:
            List[MemoryNode]: All memory nodes
        """
        return self.memory_system.get_all_memory_nodes()
        
    def get_node_by_id(self, node_id: str) -> Optional[MemoryNode]:
        """
        Get a memory node by its ID.
        
        Args:
            node_id: The ID of the memory node
            
        Returns:
            MemoryNode or None: The memory node if found, otherwise None
        """
        return self.memory_system.get_memory_node(node_id)
        
    def add_node(self, node_id: str, content: str, category: str = None) -> bool:
        """
        Add a node to the graph.
        
        Args:
            node_id: Unique identifier for the node
            content: The content associated with the node
            category: The category of the node (optional)
            
        Returns:
            bool: True if node was added, False if it already existed
        """
        if node_id not in self.graph:
            # Add node to networkx graph
            self.graph.add_node(
                node_id,
                id=node_id,
                content=content[:200],  # Store a truncated version for display
                category=category
            )
            return True
        return False
        
    def add_edge(self, source_id: str, target_id: str, 
                 weight: float = 0.5, relationship_type: str = "SIMILAR",
                 similarity: float = 0.0) -> bool:
        """
        Add an edge between two nodes.
        
        Args:
            source_id: ID of the source node
            target_id: ID of the target node
            weight: Weight of the connection (1.0 is strong, 0.3 is minimum)
            relationship_type: Type of relationship (e.g., SIMILAR, RELATED, CAUSE_EFFECT)
            similarity: The calculated similarity score (for reference)
            
        Returns:
            bool: True if edge was added, False if source/target didn't exist or edge already existed
        """
        # Ensure both nodes exist
        if source_id not in self.graph or target_id not in self.graph:
            logger.warning(f"One of the nodes not found - source: {source_id}, target: {target_id}")
            return False
            
        # Check if edge already exists
        if (source_id, target_id) in self.graph.edges:
            logger.debug(f"Edge already exists between {source_id[:8]} and {target_id[:8]}")
            return False
            
        # Add weighted edge
        self.graph.add_edge(
            source_id,
            target_id,
            weight=weight,
            type=relationship_type,
            similarity=similarity
        )
        logger.debug(f"Added edge {source_id[:8]}-{target_id[:8]} with weight {weight:.3f}")
        return True
        
    def remove_edge(self, source_id: str, target_id: str) -> bool:
        """
        Remove an edge between two nodes if it exists.
        
        Args:
            source_id: ID of the source node
            target_id: ID of the target node
            
        Returns:
            bool: True if edge was removed, False if edge didn't exist or nodes missing
        """
        if source_id not in self.graph or target_id not in self.graph:
            logger.warning(f"Node not found for removal: source {source_id} or target {target_id}")
            return False
            
        if (source_id, target_id) in self.graph.edges:
            self.graph.remove_edge(source_id, target_id)
            logger.debug(f"Removed edge between {source_id[:8]} and {target_id[:8]}")
            return True
        return False
        
    def get_neighbors(self, node_id: str, distance: int = 1) -> Dict[str, dict]:
        """
        Get all neighbors of a node within a certain graph distance.
        
        Args:
            node_id: The ID of the node to find neighbors for
            distance: Maximum graph distance to consider
            
        Returns:
            Dict[str, dict]: Dictionary of neighbor IDs to their connection properties
        """
        if node_id not in self.graph:
            logger.warning(f"Node not found for neighbor search: {node_id}")
            return {}
            
        neighbors = {}
        
        # Get immediate neighbors
        for neighbor_id, edge_data in self.graph.neighbors(node_id, data=True):
            # Get the memory node for neighbor info
            neighbor_node = self.get_node_by_id(neighbor_id)
            neighbors[neighbor_id] = {
                **edge_data,  # Connection data
                "content": neighbor_node.content[:100] if neighbor_node else "Content unavailable",
                "category": neighbor_node.category if neighbor_node else "Unknown",
                "relevance": edge_data.get("weight", 0.5)  # Higher weight = more relevant
            }
            
        # Get connections through friends-of-friends for distance > 1
        if distance > 1:
            visited = set([node_id])
            current_level = {node_id: {"type": "node", "data": { **self.graph.nodes[node_id] if node_id in self.graph.nodes else {}} }}
            
            for level in range(1, distance):
                next_level = {}
                for current_id, current_data in current_level.items():
                    for friend_id, edge_data in self.graph.neighbors(current_id, data=True):
                        if friend_id not in visited:
                            visited.add(friend_id)
                            neighbor_node = self.get_node_by_id(friend_id)
                            next_level[friend_id] = {
                                **edge_data,  # Connection data
                                "content": neighbor_node.content[:100] if neighbor_node else "Content unavailable",
                                "category": neighbor_node.category if neighbor_node else "Unknown",
                                "relevance": edge_data.get("weight", 0.5)
                            }
                current_level = next_level
                if not current_level:
                    break
                
            # Merge friends-of-friends into neighbors
            for friend_id, friend_data in current_level.items():
                if friend_id not in neighbors:
                    neighbors[friend_id] = friend_data
                    
        return neighbors
        
    def find_path(self, source_id: str, target_id: str, max_hops: int = 5) -> List[str]:
        """
        Find a path between two nodes in the graph.
        
        Args:
            source_id: ID of the starting node
            target_id: ID of the ending node
            max_hops: Maximum number of hops to consider
            
        Returns:
            List[str]: List of node IDs in the path, or None if no path exists
        """
        if source_id not in self.graph or target_id not in self.graph:
            logger.warning(f"Unable to find path - source {source_id} or target {target_id} not found")
            return None
            
        try:
            # Use BFS to find the shortest path
            path = nx.shortest_path(self.graph, source_id, target_id, method='networkx')
            if len(path) > max_hops:
                logger.warning(f"Path too long ({len(path)} hops) between {source_id} and {target_id}")
                return None
                
            return list(path)
        except nx.NetworkXNoPath:
            logger.warning(f"No path found from {source_id} to {target_id}")
            return None
            
    def _calculate_similarity(self, node1: MemoryNode, node2: MemoryNode) -> float:
        """
        Calculate semantic similarity between two memory nodes.
        
        Args:
            node1: First memory node
            node2: Second memory node
            
        Returns:
            float: Similarity score between 0.3 and 1.0
        """
        # In a complete implementation, use vector embeddings
        # This is a simplified demonstration using cosine similarity of embeddings
        
        # For demonstration purposes, we'll calculate a similarity based on:
        # - Shared words
        # - Similar structure
        # - Category alignment
        
        # Calculate shared words score
        words1 = set(node1.content.lower().split())
        words2 = set(node2.content.lower().split())
        shared_words = words1.intersection(words2)
        
        shared_score = len(shared_words) / max(len(words1), len(words2), 1)
        
        # Add some noise if nodes are in the same category
        if node1.category == node2.category:
            category_boost = 0.2
        else:
            category_boost = 0
            
        # Combine shared score and category boost with some randomness
        # This simulates how embeddings would work but is simpler to calculate
        similarity = (shared_score * 0.7) + (category_boost * 0.3) + (random.uniform(0.05, 0.15))
        
        # Ensure similarity doesn't go below minimum threshold (0.3) or above 1.0
        similarity = max(0.3, min(1.0, similarity))
        return similarity
        
    def visualize_graph(self, output_file: str = "memory_graph.png"):
        """
        Create a visualization of the memory graph.
        
        Args:
            output_file: File path to save the visualization (default: memory_graph.png)
        """
        # Simple visualization using networkx and matplotlib
        try:
            import matplotlib.pyplot as plt
            
            plt.figure(figsize=(14, 10))
            # Draw the graph with node sizes proportional to confidence (but inverted for visibility)
            node_sizes = [self.get_node_by_id(node_id).confidence * 1000 for node_id in self.graph.nodes]
            # But adjust to invert the size (more confident nodes are smaller but stand out more)
            min_size = 100
            max_size = 5000
            normed = [max(min_size, min(max_size, int((x - min_size) / (max_size - min_size) * 1000 + min_size))) for x in node_sizes]
            
            # Layout the graph
            pos = nx.spring_layout(self.graph, k=0.5, seed=42)
            
            # Draw edges with thickness proportional to weight
            edge_weights = [self.graph[u][v].get('weight', 0.5) for u, v in self.graph.edges]
            nx.draw_networkx_edges(
                self.graph, pos, 
                width=[w * 20 for w in edge_weights],
                edge_color="gray", alpha=0.4
            )
            
            # Draw nodes with labels and custom styling
            labels = {node_id[:8] + "..." if len(node_id) > 8 else node_id: 
                      self.get_node_by_id(node_id).category for node_id in self.graph.nodes}
            
            nx.draw_networkx_nodes(
                self.graph, pos, 
                nodelist=self.graph.nodes, 
                node_size=normed,
                node_color='lightblue',
                alpha=0.8
            )
            nx.draw_networkx_labels(self.graph, pos, labels=labels, font_size=10)
            
            plt.title("Memory Network Graph")
            plt.axis('off')
            plt.savefig(output_file, format="PNG", dpi=300)
            plt.close()
            logger.info(f"Memory graph visualization saved to {output_file}")
            
        except ModuleNotFoundError:
            logger.warning("matplotlib not installed. Skipping graph visualization.")
        except Exception as e:
            logger.error(f"Error during graph visualization: {str(e)}")
```

### Key Features of the MemoryGraph Class

1. **Graph-Based Memory Representation**
   - Uses NetworkX for graph operations
   - Models memory as nodes and relationships as edges
   - Supports weighted edges for connection strength

2. **Memory Connections**
   - Creates bidirectional relationships between memory nodes
   - Organizes connections in a graph structure
   - Supports different types of relationships

3. **Graph Traversal**
   - Finds relevant nodes within a graph distance
   - Identifies paths between memory concepts
   - Supports BFS for shortest path calculation

4. **Visualization**
   - Provides a visual representation of the memory graph
   - Uses node size to indicate memory confidence level
   - Visualizes connection strength with edge thickness

5. **Integration with Memory System**
   - Works closely with the MemorySystem class
   - Persists graph relationships in a separate database structure
   - Maintains consistency with memory content

This implementation will work alongside the `memory.py` to create a comprehensive cognitive model. The MemoryGraph allows the AI to understand context by following connections between memory nodes, similar to how human cognition links related ideas.

Would you like me to provide the next component now?