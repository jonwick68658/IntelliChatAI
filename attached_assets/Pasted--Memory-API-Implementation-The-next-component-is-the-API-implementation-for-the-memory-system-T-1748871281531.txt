# Memory API Implementation

The next component is the API implementation for the memory system. This will allow external services to interact with the memory system's functionality.

Here's the implementation for `memory_api.py`:

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Optional
import os
from memory import MemorySystem
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

app = FastAPI()

# Create a global memory system instance
memory_system = MemorySystem()

class MemoryRequest(BaseModel):
    content: str
    confidence: Optional[float] = 0.8
    
class MemoryResponse(BaseModel):
    id: str
    content: str
    confidence: float
    category: str
    timestamp: str
    
class RetrieveMemoryRequest(BaseModel):
    query: str
    context: Optional[str] = None
    depth: Optional[int] = 5
    
class MemoryOperationRequest(BaseModel):
    memory_id: str
    
class MemoryOperationResponse(BaseModel):
    success: bool
    message: str
    details: Optional[Dict] = None
    
class MemoryDecayRequest(BaseModel):
    force_decay: Optional[bool] = False
    
@app.post("/memorize/", response_model=MemoryResponse)
async def memorize_content(memory_request: MemoryRequest):
    """
    Add new content to memory
    """
    try:
        memory_id = memory_system.add_memory(
            content=memory_request.content,
            confidence=memory_request.confidence
        )
        
        memory_node = memory_system.get_memory_node(memory_id)
        if not memory_node:
            raise HTTPException(status_code=404, detail="Memory creation failed")
            
        return MemoryResponse(
            id=memory_node.id,
            content=memory_node.content[:1000],
            confidence=memory_node.confidence,
            category=memory_node.category,
            timestamp=memory_node.timestamp.isoformat()
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        
@app.post("/retrieve/", response_model=List[MemoryResponse])
async def retrieve_memories(retrieve_request: RetrieveMemoryRequest):
    """
    Retrieve relevant memories based on query
    """
    try:
        memories = memory_system.retrieve_memories(
            query=retrieve_request.query,
            context=retrieve_request.context,
            depth=retrieve_request.depth
        )
        
        # Convert to response format
        memory_responses = []
        for memory_node in memories:
            memory_responses.append(MemoryResponse(
                id=memory_node.id,
                content=memory_node.content[:1000],
                confidence=memory_node.confidence,
                category=memory_node.category,
                timestamp=memory_node.timestamp.isoformat()
            ))
            
        return memory_responses
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        
@app.put("/enhance/{memory_id}")
async def enhance_memory(memory_id: str):
    """
    Enhance a memory by reinforcing it
    """
    try:
        memory = memory_system.get_memory_node(memory_id)
        if not memory:
            raise HTTPException(status_code=404, detail="Memory not found")
            
        memory_system.reinforce_memory(memory_id, reinforcement=1.0)
        
        return {
            "success": True,
            "message": "Memory enhanced successfully",
            "details": {
                "memory_id": memory_id,
                "new_confidence": memory.confidence
            }
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        
@app.put("/decay/")
async def decay_memories(decay_request: MemoryDecayRequest):
    """
    Trigger memory decay process
    """
    try:
        memory_system.decay_memories(force_decay=decay_request.force_decay)
        return {
            "success": True,
            "message": "Memory decay process initiated",
            "details": {
                "force_decay": decay_request.force_decay
            }
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))        
      
@app.post("/forget/{memory_id}")
async def forget_memory(memory_id: str):
    """
    Permanently remove a memory from the system
    """
    try:
        memory_system.forget_memory(memory_id)
        return {
            "success": True,
            "message": "Memory successfully forgotten"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
        
@app.get("/health")
async def health_check():
    """
    Health check endpoint
    """
    try:
        return {
            "status": "healthy",
            "version": "1.0.0",
            "timestamp": datetime.datetime.now().isoformat()
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### Key Features of the Memory API

1. **Memory Ingestion**:
   - `/memorize/`: Stores new information in the memory system
   - Returns a response with memory details and ID

2. **Memory Retrieval**:
   - `/retrieve/`: Finds relevant memories based on query
   - Supports contextual filtering and depth controls

3. **Memory Management**:
   - `/enhance/{memory_id}`: Improves a memory through reinforcement
   - `/decay/`: Manages automatic memory decay according to policies
   - `/forget/{memory_id}`: Permanently removes a specific memory

4. **Health Check**:
   - `/health`: Endpoint to verify API status

5. **Error Handling**:
   - Proper HTTP error codes for different error conditions
   - Detailed error messages with context

The API uses:
- FastAPI for high-performance RESTful endpoints
- Pydantic for request validation and response formatting
- Environment variables for configuration (from a `.env` file)

Would you like me to proceed with the next component, which would be the UI implementation?